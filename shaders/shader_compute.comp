#version 450

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Structure matching the Particle struct in C++
struct Particle {
    vec2 position;
    vec2 velocity;
    vec4 color;
};

// Binding locations
layout(binding = 0) uniform UniformBufferObject {
    float deltaTime;
} ubo;

layout(binding = 1) buffer ParticleBufferIn {
    Particle particlesIn[];
};

layout(binding = 2) buffer ParticleBufferOut {
    Particle particlesOut[];
};

// Maze-like structures
// For simplicity, let's assume maze walls are axis-aligned rectangles
struct Wall {
    vec2 min;
    vec2 max;
};

layout(binding = 3) buffer WallBuffer {
    Wall walls[];
};

// Additional uniform for wall count
layout(binding = 4) uniform WallCountBuffer {
    uint wallCount;
} wallCountBuffer;

// Constants
const vec2 gravity = vec2(0.0f, 0.000098f); // Gravity acceleration

void main() {
    uint idx = gl_GlobalInvocationID.x;
    Particle p = particlesIn[idx];

    // Apply gravity
    p.velocity += gravity * ubo.deltaTime;

    // Update position
    p.position += p.velocity * ubo.deltaTime;

    // Collision detection with walls
    for (uint i = 0; i < wallCountBuffer.wallCount; ++i) {
        Wall w = walls[i];
        if (p.position.x >= w.min.x && p.position.x <= w.max.x &&
            p.position.y <= w.min.y && p.position.y >= w.max.y) {
            // Simple collision response: stop the particle
            p.velocity = vec2(0.0f, 0.0f);
            // Clamp position to the wall boundary
            p.position.y = w.max.y;
        }
    }

    particlesOut[idx] = p;
}
